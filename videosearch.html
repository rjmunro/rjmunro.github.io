<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Video Binary Search</title>
<style>
  /* Basic setup for a full-screen, dark-themed layout */
  html, body {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    font-family: 'Inter', sans-serif;
    overflow:hidden;
    background:#111;
  }
  /* Container to manage flexible canvas sizing */
  #canvasContainer {
    flex:1; /* Takes up all available vertical space */
    display:flex;
    justify-content:center;
    align-items:center;
    width:100%;
  }
  /* Canvas styling */
  canvas {
    border:3px solid #333; /* Dark border */
    background:#000;
    cursor:pointer;
    border-radius: 8px; /* Rounded corners for modern look */
    box-shadow: 0 4px 12px rgba(0, 255, 255, 0.1); /* Subtle glow effect */
  }
  /* Controls section, initially hidden until a video is loaded */
  #controls {
    display:none;
    margin:15px;
    color:white;
    text-align: center;
    padding: 10px;
  }
  #messageBox {
    color: #00bcd4; /* Cyan/Info color for status messages */
    font-weight: bold;
    margin-bottom: 15px;
    height: 1.2em; /* Ensure stable layout */
    font-size: 1.05em;
  }
  #controls p {
    font-size: 1.1em;
    margin-bottom: 10px;
  }
  #controls button {
    margin:5px;
    font-size:16px;
    padding:10px 20px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
    border: none;
    font-weight: bold;
  }
  #yesBtn { background-color: #4CAF50; color: white; } /* Green for 'Yes' (Upper Bound) */
  #noBtn { background-color: #f44336; color: white; } /* Red for 'No' (Lower Bound) */
  #saveBtn { margin-top:10px; display:none; background-color: #00bcd4; color: white; } /* Cyan for 'Save' */

  #yesBtn:hover { background-color: #45a049; }
  #noBtn:hover { background-color: #da3328; }
  #saveBtn:hover { background-color: #00acc1; }

  /* Tooltip for showing hover time on the timeline */
  #tooltip {
    position:absolute;
    padding:6px 10px;
    background: rgba(255,255,255,0.9);
    color:#111;
    font-size:14px;
    border-radius:4px;
    pointer-events:none; /* Allows clicking through to the canvas */
    display:none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    font-weight: 500;
  }
</style>
</head>
<body>
<div id="canvasContainer">
  <canvas id="canvas"></canvas>
  <div id="tooltip"></div>
</div>
<div id="controls">
  <!-- Clarified instruction to reflect that 'Yes' sets the upper bound (earlier time) and 'No' sets the lower bound (later time) -->
  <p>Has the event you are searching for occurred **BEFORE or AT** this frame?</p>
  <div id="messageBox">Drag and drop a video file here to begin.</div>
  <button id="yesBtn">Yes (Go Backwards)</button>
  <button id="noBtn">No (Go Forwards)</button>
  <button id="saveBtn">Save Timestamp</button>
</div>
<script>
// --- DOM Element Fetching ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const controls = document.getElementById('controls');
const yesBtn = document.getElementById('yesBtn');
const noBtn = document.getElementById('noBtn');
const saveBtn = document.getElementById('saveBtn');
const tooltip = document.getElementById('tooltip');
const messageBox = document.getElementById('messageBox');

// --- Video Element Setup ---
let video = document.createElement('video');
video.crossOrigin = 'anonymous';
// NOTE: video.muted is NOT set to true, as requested by the user.
video.playsInline = true;
video.preload = 'auto';
video.style.display = 'none';

// --- State Variables and Constants ---
let markers = [];         // Stores {time, color} for 'Yes' (green) and 'No' (red) responses
let start = 0, end = 0;   // Current search range bounds (start/end time in seconds)
let current = 0;          // The current timestamp being displayed (binary search midpoint or scrub position)
let timelineHeight = 50;  // Fixed height for the timeline visualization
let videoAspect = 16/9;   // Default aspect ratio for video resizing
let isDraggingTimeline = false; // State for continuous scrubbing
let scrubTargetTime = null; // The time the video should play to and then pause

// --- Constants for Seeking ---
const SEEK_STEP_SMALL = 0.1;      // For Arrow keys (100ms jump)
const SEEK_STEP_FRAME = 0.0333;   // Approximate 1/30th of a second for frame step

// --- Time Formatting Utility ---
function formatTime(totalSeconds) {
    if (isNaN(totalSeconds) || totalSeconds < 0) return '00:00.00';

    const secs = Math.floor(Math.max(0, totalSeconds));
    const fractional = Math.floor((totalSeconds - secs) * 100);
    const hours = Math.floor(secs / 3600);
    const minutes = Math.floor((secs % 3600) / 60);
    const remainingSeconds = secs % 60;

    const formattedMinutes = String(minutes).padStart(2, '0');
    const formattedSeconds = String(remainingSeconds).padStart(2, '0');
    const formattedFractional = String(fractional).padStart(2, '0');

    if (hours > 0) {
        const formattedHours = String(hours).padStart(2, '0');
        return `${formattedHours}:${formattedMinutes}:${formattedSeconds}.${formattedFractional}`;
    } else {
        return `${formattedMinutes}:${formattedSeconds}.${formattedFractional}`;
    }
}


// --- Responsive Canvas Resizing ---
function resizeCanvas(){
    const containerWidth = window.innerWidth;
    const containerHeight = window.innerHeight - controls.offsetHeight;
    const maxWidth = containerWidth * 0.95;
    const maxHeight = containerHeight * 0.95;

    // Calculate canvas size based on video aspect ratio to fit within container
    if(maxWidth/maxHeight > videoAspect){
        canvas.height = maxHeight;
        canvas.width = maxHeight * videoAspect;
    } else {
        canvas.width = maxWidth;
        canvas.height = maxWidth / videoAspect;
    }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); // Initial call

// --- Drawing the Timeline at the bottom of the Canvas ---
function drawTimeline(){
    // 1. Draw the base timeline bar
    ctx.fillStyle = '#333';
    ctx.fillRect(0, canvas.height - timelineHeight, canvas.width, timelineHeight);

    // 2. Draw the current search range (light blue highlight)
    const startX = start / video.duration * canvas.width;
    const endX = end / video.duration * canvas.width;
    const width = endX - startX;
    ctx.fillStyle = 'rgba(0, 188, 212, 0.2)'; // Cyan with opacity
    ctx.fillRect(startX, canvas.height - timelineHeight, width, timelineHeight);

    // 3. Draw all existing markers (red for 'no', green for 'yes')
    markers.forEach(m => {
        ctx.fillStyle = m.color;
        const x = m.time / video.duration * canvas.width;
        ctx.fillRect(x - 3, canvas.height - timelineHeight, 6, timelineHeight);
    });

    // 4. Draw the current playback/seek indicator (yellow cursor)
    if(video.duration > 0){
        const x = video.currentTime / video.duration * canvas.width;
        const yBottom = canvas.height;
        const yTop = canvas.height - timelineHeight;
        const triangleHeight = timelineHeight / 3;

        // Draw the vertical line part of the indicator
        ctx.beginPath();
        ctx.moveTo(x, yTop);
        ctx.lineTo(x, yBottom - triangleHeight);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw the triangle pointer at the bottom
        ctx.beginPath();
        ctx.moveTo(x, yBottom - triangleHeight);
        ctx.lineTo(x - 6, yBottom);
        ctx.lineTo(x + 6, yBottom);
        ctx.closePath();
        ctx.fillStyle = 'yellow';
        ctx.fill();
    }
}

// --- Video Seeking Utility ---
function seekTo(time){
    video.currentTime = Math.max(0, Math.min(video.duration, time));
}

// --- Main Animation Loop to Draw Video and Timeline ---
function drawVideoFrame(){
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

    // Fix for black flash: Draw video immediately if dimensions are valid.
    // This maintains the previous frame while the video seeks.
    if(video.videoWidth > 0 && video.videoHeight > 0){
        const videoHeight = canvas.height - timelineHeight;
        const videoWidth = videoHeight * video.videoWidth / video.videoHeight;
        const offsetX = (canvas.width - videoWidth) / 2;

        ctx.drawImage(video, offsetX, 0, videoWidth, videoHeight);

        // --- Play-to-Target Pause Logic ---
        if (scrubTargetTime !== null && !video.paused) {
            // Check if current time has reached or passed the target
            if (video.currentTime >= scrubTargetTime) {
                video.pause();
                seekTo(scrubTargetTime); // Ensure it stops exactly on the target frame
                scrubTargetTime = null; // Clear the target
                current = video.currentTime;
            }
        }
    }

    // Looping Logic: If playing for binary search review (not scrubbing), loop back to start.
    if (!video.paused && video.duration > 0 && scrubTargetTime === null) {
        if (video.currentTime >= end - 0.05) {
            seekTo(start);
        }
    }

    drawTimeline(); // Always draw the timeline
    requestAnimationFrame(drawVideoFrame); // Loop
}


// --- Marker Management & Binary Search Logic (Unchanged) ---

function addMarker(time, color){
    markers.push({time, color});
    markers.sort((a, b) => a.time - b.time);
}

function getLastMarkers(){
    const noMarkers = markers.filter(m => m.color === 'red');
    const yesMarkers = markers.filter(m => m.color === 'green');

    const lastNo = noMarkers.length ? noMarkers[noMarkers.length - 1].time : 0;
    const firstYes = yesMarkers.length ? yesMarkers[0].time : video.duration;

    return { lastNo, firstYes };
}

function binaryStep(answer){
    // Ensure scrubbing target is cleared and paused before making a decision
    scrubTargetTime = null;
    video.pause();

    const markTime = video.currentTime;
    const color = answer === 'yes' ? 'green' : 'red';

    // 1. Conflict Resolution
    if (color === 'green') {
        markers = markers.filter(m => !(m.color === 'red' && m.time >= markTime));
    } else {
        markers = markers.filter(m => !(m.color === 'green' && m.time <= markTime));
    }
    markers.sort((a, b) => a.time - b.time);

    // 2. Add the new marker
    addMarker(markTime, color);
    current = markTime;

    // 3. Recalculate Boundaries
    const { lastNo, firstYes } = getLastMarkers();
    start = lastNo;
    end = firstYes;

    // 4. Calculate the new midpoint
    const nextCurrent = start + (end - start) / 2;

    // 5. Check for termination condition
    if(Math.abs(end - start) < 0.05){
        messageBox.textContent = `✅ Event found at: ${formatTime(current)}!`;
        saveBtn.style.display = 'inline';
        video.pause();
        return;
    }

    // 6. Seek to the new midpoint
    seekTo(nextCurrent);
    current = nextCurrent;
    messageBox.textContent = `Current search range: ${formatTime(start)} to ${formatTime(end)}.`;
    video.pause();
}

// --- Helper to calculate time based on mouse x position ---
function calculateTimeFromEvent(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const clampedX = Math.max(0, Math.min(canvas.width, x));

    return clampedX / canvas.width * video.duration;
}

// --- Timeline Scrubbing Logic ---
function handleTimelineScrub(event) {
    if(!video.duration || !isDraggingTimeline) return;

    const targetTime = calculateTimeFromEvent(event);
    const currentTime = video.currentTime;
    const delta = targetTime - currentTime; // Difference between target and current playback time

    current = targetTime; // Update indicator position immediately

    // Check if the drag is strictly forward (delta > 0) AND within the 5-second window.
    const isShortForwardDrag = (delta > 0 && delta <= 5);

    if (isShortForwardDrag) {
        // --- Play-to-Point Logic ---
        scrubTargetTime = targetTime; // Set the stop point
        if (video.paused) {
            // Start playing only if it's currently paused
            video.play();
        }
        // No instant seek: let the video play naturally toward scrubTargetTime.
    } else {
        // --- Instant Seek Logic (Backward drag, stationary, or long forward drag) ---
        // This covers: delta <= 0 (backward/stationary) OR delta > 5 (long jump).
        scrubTargetTime = null; // Clear any existing play-to-point target
        if (!video.paused) {
            video.pause(); // Explicitly pause if it was playing
        }
        seekTo(targetTime); // Instant jump/seek to the mouse position
    }
}

// --- File Drag and Drop Setup (Unchanged) ---
function fileDropSetup(){
    window.addEventListener('dragover', e => e.preventDefault());

    window.addEventListener('drop', e => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];

        if(file && file.type.startsWith('video/')){
            const url = URL.createObjectURL(file);
            video.src = url;

            video.addEventListener('loadedmetadata', () => {
                videoAspect = video.videoWidth / video.videoHeight;
                resizeCanvas();

                // Initialize binary search bounds
                start = 0;
                end = video.duration;
                current = (start + end) / 2;
                markers = [];
                scrubTargetTime = null; // Reset scrub target

                seekTo(current);
                video.pause();

                controls.style.display = 'block';
                messageBox.textContent = `Current search range: ${formatTime(start)} to ${formatTime(end)}.`;
            }, { once: true });
        }
    });
}

fileDropSetup();

// --- Event Listeners for Interaction ---

// MOUSE DOWN (Handles start of scrubbing or video play/pause)
canvas.addEventListener('mousedown', (event) => {
    if (!video.duration) return;

    const rect = canvas.getBoundingClientRect();
    const y = event.clientY - rect.top;
    const isTimelineClick = y > (canvas.height - timelineHeight);

    if (isTimelineClick) {
        // Timeline Mousedown: Start dragging
        isDraggingTimeline = true;
        // Perform initial seek/play logic
        handleTimelineScrub(event);
        event.preventDefault();
    } else {
        // Video Area Click: Play/Pause Toggle
        scrubTargetTime = null; // Clear any existing scrub targets
        if (video.paused || video.ended) {
            video.play();
        } else {
            video.pause();
        }
    }
});

// MOUSE MOVE (Handles continuous scrubbing and tooltip update)
canvas.addEventListener('mousemove', e => {
    if(!video.duration) return;

    const rect = canvas.getBoundingClientRect();
    const y = e.clientY - rect.top;

    const isOverTimeline = y > (canvas.height - timelineHeight) &&
                           y < canvas.height;

    if (isDraggingTimeline) {
        // Continuous scrubbing is active
        handleTimelineScrub(e);
    }

    // Tooltip management
    if (isOverTimeline || isDraggingTimeline) {
        const hoverTime = calculateTimeFromEvent(e);
        tooltip.style.display = 'block';
        tooltip.style.left = e.clientX + 10 + 'px';
        tooltip.style.top = e.clientY + 10 + 'px';
        tooltip.textContent = formatTime(hoverTime);
    } else {
        tooltip.style.display = 'none';
    }
});

// MOUSE UP (Stops scrubbing) - Use window to catch releases outside the canvas
window.addEventListener('mouseup', () => {
    if (isDraggingTimeline) {
        // When dragging stops, perform a final pause and clear the target
        video.pause();
        scrubTargetTime = null;
    }
    isDraggingTimeline = false;
});

// Other button listeners
yesBtn.addEventListener('click', () => binaryStep('yes'));
noBtn.addEventListener('click', () => binaryStep('no'));

// Save button functionality
saveBtn.addEventListener('click', () => {
    const timestamp = current.toFixed(2);
    const blob = new Blob([timestamp], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `event_timestamp_${formatTime(current).replace(/[:.]/g, '-')}.txt`;
    a.click();
    URL.revokeObjectURL(a.href);
});

canvas.addEventListener('mouseleave', () => {
    if (!isDraggingTimeline) {
        tooltip.style.display = 'none';
    }
});

// --- Keyboard Interaction ---
function handleKeyPress(e) {
    if (!video.duration) return; // Ignore if no video is loaded

    // Prevent default actions for keys we handle (like space scrolling the page)
    if ([' ', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ',', '.'].includes(e.key)) {
        e.preventDefault();
    }

    // Stop all playback/scrubbing before any keyboard action
    if (isDraggingTimeline) return;
    scrubTargetTime = null;

    // Explicitly pause if not toggling play/pause, otherwise, allow play/pause to run
    if(e.key !== ' '){
        video.pause();
    }

    switch (e.key) {
        case ' ': // Spacebar: Play/Pause
            if (video.paused || video.ended) {
                video.play();
            } else {
                video.pause();
            }
            break;

        case 'ArrowRight': // Right Arrow: Seek forward 0.1s
            seekTo(video.currentTime + SEEK_STEP_SMALL);
            break;

        case 'ArrowLeft': // Left Arrow: Seek backward 0.1s
            seekTo(video.currentTime - SEEK_STEP_SMALL);
            break;

        case '.': // '.' key: Frame forward (assuming 30fps)
            seekTo(video.currentTime + SEEK_STEP_FRAME);
            break;

        case ',': // ',' key: Frame backward (assuming 30fps)
            seekTo(video.currentTime - SEEK_STEP_FRAME);
            break;

        case 'ArrowDown': // Down Arrow: 'Yes' (Go Backwards)
            yesBtn.click();
            break;

        case 'ArrowUp': // Up Arrow: 'No' (Go Forwards)
            noBtn.click();
            break;
    }
    // Update 'current' state after seeking to ensure the indicator matches the video time immediately
    current = video.currentTime;
}

window.addEventListener('keydown', handleKeyPress);


// --- Start the Drawing Loop ---
requestAnimationFrame(drawVideoFrame);
</script>
</body>
</html>
