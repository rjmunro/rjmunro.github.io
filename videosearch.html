<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Video Binary Search</title>
<style>
  /* Basic setup for a full-screen, dark-themed layout */
  html, body {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    font-family: 'Inter', sans-serif;
    overflow:hidden;
    background:#111;
  }
  /* Container to manage flexible canvas sizing */
  #canvasContainer {
    flex:1; /* Takes up all available vertical space */
    display:flex;
    justify-content:center;
    align-items:center;
    width:100%;
  }
  /* Canvas styling */
  canvas {
    border:3px solid #333; /* Dark border */
    background:#000;
    cursor:pointer;
    border-radius: 8px; /* Rounded corners for modern look */
    box-shadow: 0 4px 12px rgba(0, 255, 255, 0.1); /* Subtle glow effect */
  }
  /* Controls section, initially hidden until a video is loaded */
  #controls {
    display:none;
    margin:15px;
    color:white;
    text-align: center;
    padding: 10px;
  }
  #messageBox {
    color: #00bcd4; /* Cyan/Info color for status messages */
    font-weight: bold;
    margin-bottom: 15px;
    height: 1.2em; /* Ensure stable layout */
    font-size: 1.05em;
  }
  #controls p {
    font-size: 1.1em;
    margin-bottom: 10px;
  }
  #controls button {
    margin:5px;
    font-size:16px;
    padding:10px 20px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
    border: none;
    font-weight: bold;
  }
  #yesBtn { background-color: #4CAF50; color: white; } /* Green for 'Yes' (Upper Bound) */
  #noBtn { background-color: #f44336; color: white; } /* Red for 'No' (Lower Bound) */
  #saveBtn { margin-top:10px; display:none; background-color: #00bcd4; color: white; } /* Cyan for 'Save' */

  #yesBtn:hover { background-color: #45a049; }
  #noBtn:hover { background-color: #da3328; }
  #saveBtn:hover { background-color: #00acc1; }

  /* Tooltip for showing hover time on the timeline */
  #tooltip {
    position:absolute;
    padding:6px 10px;
    background: rgba(255,255,255,0.9);
    color:#111;
    font-size:14px;
    border-radius:4px;
    pointer-events:none; /* Allows clicking through to the canvas */
    display:none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    font-weight: 500;
  }
</style>
</head>
<body>
<div id="canvasContainer">
  <canvas id="canvas"></canvas>
  <div id="tooltip"></div>
</div>
<div id="controls">
  <!-- Clarified instruction to reflect that 'Yes' sets the upper bound (earlier time) and 'No' sets the lower bound (later time) -->
  <p>Has the event you are searching for occurred **BEFORE or AT** this frame?</p>
  <div id="messageBox">Drag and drop a video file here to begin.</div>
  <button id="yesBtn">Yes (Go Backwards)</button>
  <button id="noBtn">No (Go Forwards)</button>
  <button id="saveBtn">Save Timestamp</button>
</div>
<script>
// --- DOM Element Fetching ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const controls = document.getElementById('controls');
const yesBtn = document.getElementById('yesBtn');
const noBtn = document.getElementById('noBtn');
const saveBtn = document.getElementById('saveBtn');
const tooltip = document.getElementById('tooltip');
const messageBox = document.getElementById('messageBox');

// --- Video Element Setup (Created in JS to avoid initial DOM clutter) ---
let video = document.createElement('video');
video.crossOrigin = 'anonymous'; // Important for canvas drawing (prevents tainting)
video.muted = true;
video.playsInline = true;
video.preload = 'auto';
video.style.display = 'none';

// --- State Variables ---
let markers = [];         // Stores {time, color} for 'Yes' (green) and 'No' (red) responses
let start = 0, end = 0;   // Current search range bounds (start/end time in seconds)
let current = 0;          // The current timestamp being displayed
let timelineHeight = 50;  // Fixed height for the timeline visualization
let videoAspect = 16/9;   // Default aspect ratio for video resizing
let readyFrame = false;   // Flag to ensure a frame is ready after seeking

// --- Time Formatting Utility ---
function formatTime(totalSeconds) {
    if (isNaN(totalSeconds) || totalSeconds < 0) return '00:00.00';

    // Ensure seconds is a non-negative number
    const secs = Math.floor(Math.max(0, totalSeconds));

    // Calculate fractional part (hundredths of a second)
    const fractional = Math.floor((totalSeconds - secs) * 100);

    // Calculate hours, minutes, and remaining seconds
    const hours = Math.floor(secs / 3600);
    const minutes = Math.floor((secs % 3600) / 60);
    const remainingSeconds = secs % 60;

    const formattedMinutes = String(minutes).padStart(2, '0');
    const formattedSeconds = String(remainingSeconds).padStart(2, '0');
    const formattedFractional = String(fractional).padStart(2, '0');

    if (hours > 0) {
        // If duration is an hour or more, include hours
        const formattedHours = String(hours).padStart(2, '0');
        return `${formattedHours}:${formattedMinutes}:${formattedSeconds}.${formattedFractional}`;
    } else {
        // Otherwise, use mm:ss.xx format
        return `${formattedMinutes}:${formattedSeconds}.${formattedFractional}`;
    }
}


// --- Responsive Canvas Resizing ---
function resizeCanvas(){
    const containerWidth = window.innerWidth;
    const containerHeight = window.innerHeight - controls.offsetHeight;
    const maxWidth = containerWidth * 0.95;
    const maxHeight = containerHeight * 0.95;

    // Calculate canvas size based on video aspect ratio to fit within container
    if(maxWidth/maxHeight > videoAspect){
        // Container is too wide, height is the limiting factor
        canvas.height = maxHeight;
        canvas.width = maxHeight * videoAspect;
    } else {
        // Container is too tall, width is the limiting factor
        canvas.width = maxWidth;
        canvas.height = maxWidth / videoAspect;
    }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); // Initial call

// --- Drawing the Timeline at the bottom of the Canvas ---
function drawTimeline(){
    // 1. Draw the base timeline bar
    ctx.fillStyle = '#333';
    ctx.fillRect(0, canvas.height - timelineHeight, canvas.width, timelineHeight);

    // 2. Draw the current search range (light blue highlight)
    const startX = start / video.duration * canvas.width;
    const endX = end / video.duration * canvas.width;
    const width = endX - startX;
    ctx.fillStyle = 'rgba(0, 188, 212, 0.2)'; // Cyan with opacity
    ctx.fillRect(startX, canvas.height - timelineHeight, width, timelineHeight);


    // 3. Draw all existing markers (red for 'no', green for 'yes')
    markers.forEach(m => {
        ctx.fillStyle = m.color;
        // Convert time (seconds) to x-coordinate (pixels)
        const x = m.time / video.duration * canvas.width;
        ctx.fillRect(x - 3, canvas.height - timelineHeight, 6, timelineHeight); // 6px wide line
    });

    // 4. Draw the current playback/seek indicator (yellow cursor)
    if(video.duration > 0){
        // Calculate position of the current time
        const x = video.currentTime / video.duration * canvas.width;
        const yBottom = canvas.height;
        const yTop = canvas.height - timelineHeight;
        const triangleHeight = timelineHeight / 3;

        // Draw the vertical line part of the indicator
        ctx.beginPath();
        ctx.moveTo(x, yTop);
        ctx.lineTo(x, yBottom - triangleHeight);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw the triangle pointer at the bottom
        ctx.beginPath();
        ctx.moveTo(x, yBottom - triangleHeight);
        ctx.lineTo(x - 6, yBottom);
        ctx.lineTo(x + 6, yBottom);
        ctx.closePath();
        ctx.fillStyle = 'yellow';
        ctx.fill();
    }
}

// --- Main Animation Loop to Draw Video and Timeline ---
function drawVideoFrame(){
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

    // Only draw the video if metadata is loaded (readyState >= 2) AND the frame is marked as ready (seeked)
    if(video.readyState >= 2 && readyFrame){
        const videoHeight = canvas.height - timelineHeight;
        // Calculate scaled video width to maintain aspect ratio
        const videoWidth = videoHeight * video.videoWidth / video.videoHeight;
        // Calculate offset to center the video horizontally
        const offsetX = (canvas.width - videoWidth) / 2;

        // Draw the video frame onto the canvas
        ctx.drawImage(video, offsetX, 0, videoWidth, videoHeight);
    }

    // Looping Logic: If playing, check if we hit the 'end' boundary of the search range.
    if (!video.paused && video.duration > 0) {
        // If current time is close to the search end boundary, loop back to the search start boundary.
        if (video.currentTime >= end - 0.05) {
            seekTo(start);
        }
    }

    drawTimeline(); // Always draw the timeline
    requestAnimationFrame(drawVideoFrame); // Loop
}

// --- Marker Management ---
function addMarker(time, color){
    // Markers are only removed in binaryStep for conflict resolution,
    // here we just ensure a new marker is added and the list is sorted.
    markers.push({time, color});
    markers.sort((a, b) => a.time - b.time); // Keep markers sorted by time
}

// --- Find Current Search Bounds (Corrected Logic) ---
function getLastMarkers(){
    // Red markers ('No') define the event occurred AFTER this time (sets the floor/start bound).
    const noMarkers = markers.filter(m => m.color === 'red');
    // Green markers ('Yes') define the event occurred at or BEFORE this time (sets the ceiling/end bound).
    const yesMarkers = markers.filter(m => m.color === 'green');

    // lastNo (latest 'No') is the new 'start' boundary (or 0 if none)
    const lastNo = noMarkers.length ? noMarkers[noMarkers.length - 1].time : 0;

    // firstYes (earliest 'Yes') is the new 'end' boundary (or video duration if none)
    const firstYes = yesMarkers.length ? yesMarkers[0].time : video.duration;

    // The search space is now correctly defined as [lastNo, firstYes]
    return { lastNo, firstYes };
}

// --- Core Binary Search Logic (Triggered by 'Yes'/'No' buttons) ---
function binaryStep(answer){
    const markTime = video.currentTime; // Use the video's current playhead position
    const color = answer === 'yes' ? 'green' : 'red';

    // 1. Conflict Resolution: Remove markers that are now invalidated by the new decision.
    if (color === 'green') { // New 'Yes': event must be AT/BEFORE markTime. This sets the ceiling (end).
        // Remove any 'No' markers (event is AFTER) that fall at or after markTime, as the new 'Yes' contradicts them.
        markers = markers.filter(m => !(m.color === 'red' && m.time >= markTime));
    } else { // color === 'red' - New 'No': event must be AFTER markTime. This sets the floor (start).
        // Remove any 'Yes' markers (event is AT/BEFORE) that fall at or before markTime, as the new 'No' contradicts them.
        markers = markers.filter(m => !(m.color === 'green' && m.time <= markTime));
    }
    // Re-sort markers after potential removal
    markers.sort((a, b) => a.time - b.time);

    // 2. Add the new marker at the playhead position
    addMarker(markTime, color);
    current = markTime; // Update 'current' to the latest decision point

    // 3. Recalculate Boundaries (start/end) based on all valid markers
    const { lastNo, firstYes } = getLastMarkers();
    start = lastNo; // New search start (defined by the latest 'No' marker)
    end = firstYes; // New search end (defined by the earliest 'Yes' marker)

    // 4. Calculate the new midpoint for the next step
    const nextCurrent = start + (end - start) / 2;

    // 5. Check for termination condition
    if(Math.abs(end - start) < 0.05){
        messageBox.textContent = `✅ Event found at: ${formatTime(current)}!`;
        saveBtn.style.display = 'inline';
        video.pause();
        return;
    }

    // 6. Seek to the new midpoint
    seekTo(nextCurrent);
    current = nextCurrent; // Update 'current' for the next decision point
    messageBox.textContent = `Current search range: ${formatTime(start)} to ${formatTime(end)}.`;
    video.pause(); // Always pause after a binary step to allow assessment
}

// --- Canvas Click Handling (Combined Scrubbing and Play/Pause) ---
function handleCanvasClick(event){
    if(!video.duration) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Check if click is on the timeline area
    const isTimelineClick = y > (canvas.height - timelineHeight);

    if (isTimelineClick) {
        // Timeline Click: Manual Scrubbing
        const clickTime = x / canvas.width * video.duration;
        current = clickTime;
        seekTo(clickTime);
        video.pause(); // Pause after scrubbing
    } else {
        // Video Area Click: Play/Pause Toggle
        if (video.paused || video.ended) {
            video.play();
        } else {
            video.pause();
        }
    }
}

// --- Video Seeking Utility ---
function seekTo(time){
    readyFrame = false; // Reset flag to show seeking in progress
    video.currentTime = time;
}

// --- Seeking Completion Handler ---
video.addEventListener('seeked', () => {
    // This event fires when the video is ready at the new timestamp.
    readyFrame = true; // Set flag to allow the next drawVideoFrame cycle to show the image
});

// --- File Drag and Drop Setup ---
function fileDropSetup(){
    // Prevent default browser handling for drag/drop (e.g., opening the file)
    window.addEventListener('dragover', e => e.preventDefault());

    window.addEventListener('drop', e => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];

        if(file && file.type.startsWith('video/')){
            const url = URL.createObjectURL(file);
            video.src = url;

            // Wait for video metadata to load (duration, dimensions)
            video.addEventListener('loadedmetadata', () => {
                videoAspect = video.videoWidth / video.videoHeight;
                resizeCanvas();

                // Initialize binary search bounds
                start = 0;
                end = video.duration;
                current = (start + end) / 2; // Start in the middle
                markers = []; // Clear old markers

                seekTo(current);
                video.pause();

                controls.style.display = 'block'; // Show controls
                messageBox.textContent = `Current search range: ${formatTime(start)} to ${formatTime(end)}.`;
            }, { once: true });
        }
    });
}

fileDropSetup();

// --- Event Listeners for Interaction ---
// Replaced handleClick with handleCanvasClick
canvas.addEventListener('click', handleCanvasClick);
yesBtn.addEventListener('click', () => binaryStep('yes'));
noBtn.addEventListener('click', () => binaryStep('no'));

// Save button functionality (downloads a text file)
saveBtn.addEventListener('click', () => {
    const timestamp = current.toFixed(2);
    // Use Blob to create a file in memory
    const blob = new Blob([timestamp], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `event_timestamp_${formatTime(current).replace(/[:.]/g, '-')}.txt`;
    a.click(); // Programmatically trigger the download
    URL.revokeObjectURL(a.href); // Clean up the URL object
});

// --- Mousemove Tooltip for Timeline Hover ---
canvas.addEventListener('mousemove', e => {
    if(!video.duration) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;

    // Check if the hover is over the timeline area
    const isOverTimeline = e.clientY > (rect.top + canvas.height - timelineHeight) &&
                           e.clientY < (rect.top + canvas.height);

    if (isOverTimeline) {
      const hoverTime = x / canvas.width * video.duration;
      tooltip.style.display = 'block';
      // Offset tooltip position for better visibility
      tooltip.style.left = e.clientX + 10 + 'px';
      tooltip.style.top = e.clientY + 10 + 'px';
      tooltip.textContent = formatTime(hoverTime); // Use new format
    } else {
      tooltip.style.display = 'none';
    }
});

canvas.addEventListener('mouseleave', () => tooltip.style.display = 'none');

// --- Start the Drawing Loop ---
requestAnimationFrame(drawVideoFrame);
</script>
</body>
</html>
